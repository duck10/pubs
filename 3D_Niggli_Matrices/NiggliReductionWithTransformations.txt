bool Niggli::ReduceWithTransforms(const G6& vi, MatG6& mG6, Matrix_3x3& m3d, G6& vout, const double delta)
{
   // This implementation follows the logic of Niggli::Reduce and tracks both G6 and 3D matrices


   if (Niggli::IsNiggli(vi)) {
      vout = vi;
      mG6 = spnull;
      m3d = spnull_3D;
      return true;
   }

   G6 vin;
   MatG6 m1;
   Matrix_3x3 m3d_step;
   size_t count = 0;
   bool again = true;
   const int maxCycle = 260;

   // Initialize transformation matrices to identity
   mG6 = spnull;
   m3d = spnull_3D;

   vin = vi;
   G6 voutPrev(vin);

   // First apply MKnorm to standardize the input vector
   // This section exactly follows the logic of Niggli::MKnorm but adds 3D matrix tracking
   {
      bool againMK = true;
      int mkCycleCount = 0;
      MatG6 matG6 = spnull;
      Matrix_3x3 mat3D = spnull_3D;

      // MKnorm: assure that g1<=g2<=g3
      while (againMK && (mkCycleCount <= 5)) {
         ++mkCycleCount;
         againMK = false;

         if ((fabs(vin[0]) > fabs(vin[1]) + delta + 1.e-12 * (vin[0] + vin[1])) ||
            (fabs(vin[0] - vin[1]) < 1.e-38 + 1.e-12 * fabs(vin[0] + vin[1]) &&
               delta < 1.0E-12 && fabs(vin[3]) > fabs(vin[4]) + delta + 1.e-12 * (fabs(vin[3]) + fabs(vin[4])))) {
            // SP1
            matG6 = sp1;  // Use the global sp1
            mat3D = sp1_3D;
            againMK = true;
         }
         else if ((fabs(vin[1]) > fabs(vin[2]) + delta + 1.e-12 * (vin[1] + vin[2])) ||
            (fabs(vin[1] - vin[2]) < 1.e-38 + 1.e-12 * fabs(vin[1] + vin[2]) &&
               delta < 1.0E-12 && fabs(vin[4]) > fabs(vin[5]) + delta + 1.e-12 * (fabs(vin[4]) + fabs(vin[5])))) {
            // SP2
            matG6 = sp2;  // Use the global sp2
            mat3D = sp2_3D;
            againMK = true;
         }

         if (againMK) {
            vout = matG6 * vin;
            vin = vout;

            // Update the transformation matrices
            mG6 = matG6 * mG6;
            m3d = mat3D * m3d;
         }
      }

      // MKnorm: Ensure vector is +++ or ---
      int bMinusPattern = 0;
      int bZeroPattern = 0;
      if (vin[3] < delta + 1.0E-13 * (vin[1] + vin[2])) bMinusPattern |= 4;
      if (vin[4] < delta + 1.0E-13 * (vin[0] + vin[2])) bMinusPattern |= 2;
      if (vin[5] < delta + 1.0E-13 * (vin[0] + vin[1])) bMinusPattern |= 1;
      if (fabs(vin[3]) < delta + 1.0E-13 * (vin[1] + vin[2])) bZeroPattern |= 4;
      if (fabs(vin[4]) < delta + 1.0E-13 * (vin[0] + vin[2])) bZeroPattern |= 2;
      if (fabs(vin[5]) < delta + 1.0E-13 * (vin[0] + vin[1])) bZeroPattern |= 1;

      // These variables must be initialized here, not redeclared below
      matG6 = spnull;
      mat3D = spnull_3D;

      switch (bMinusPattern) {
      case 0:  /*  +++  */
         matG6 = spnull;  // Use the global spnull
         mat3D = spnull_3D;
         break;
      case 1:  /* ++- -> --- */
         matG6 = sp34a;  // Use the global sp34a
         mat3D = sp34a_3D;
         break;
      case 2:  /* +-+ -> --- */
         matG6 = sp34b;  // Use the global sp34b
         mat3D = sp34b_3D;
         break;
      case 3:  /* +-- -> +++, but +0- -> -0- and +-0 -> --0 and +00 -> -00 */
         if ((bZeroPattern & 2) == 2) {
            matG6 = sp34a;  // Use the global sp34a
            mat3D = sp34a_3D;
            break;
         }
         if ((bZeroPattern & 1) == 1) {
            matG6 = sp34b;  // Use the global sp34b
            mat3D = sp34b_3D;
            break;
         }
         matG6 = sp34c;  // Use the global sp34c
         mat3D = sp34c_3D;
         break;
      case 4:  /* -++ -> --- */
         matG6 = sp34c;  // Use the global sp34c
         mat3D = sp34c_3D;
         break;
      case 5:  /* -+- -> +++, but 0+- -> 0-- and -+0 -> --0 and 0+0 -> 0-0 */
         if ((bZeroPattern & 4) == 4) {
            matG6 = sp34a;  // Use the global sp34a
            mat3D = sp34a_3D;
            break;
         }
         if ((bZeroPattern & 1) == 1) {
            matG6 = sp34c;  // Use the global sp34c
            mat3D = sp34c_3D;
            break;
         }
         matG6 = sp34b;  // Use the global sp34b
         mat3D = sp34b_3D;
         break;
      case 6:  /* --+ -> +++, but 0-+ -> 0-- and -0+ -> -0- and 00+ -> 00- */
         if ((bZeroPattern & 4) == 4) {
            matG6 = sp34b;  // Use the global sp34b
            mat3D = sp34b_3D;
            break;
         }
         if ((bZeroPattern & 2) == 2) {
            matG6 = sp34c;  // Use the global sp34c
            mat3D = sp34c_3D;
            break;
         }
         matG6 = sp34a;  // Use the global sp34a
         mat3D = sp34a_3D;
         break;
      case 7:
         matG6 = spnull;  // Use the global spnull
         mat3D = spnull_3D;
         break;
      }

      vout = matG6 * vin;
      vin = vout;

      // Update the transformation matrices
      mG6 = matG6 * mG6;
      m3d = mat3D * m3d;
   }

   // Main reduction loop - following the logic of Niggli::Reduce
   while (again && count < maxCycle) {
      m1 = spnull; // Reset for this iteration
      m3d_step = spnull_3D; // Reset for this iteration

      if (fabs(vin[3]) > fabs(vin[1]) + delta) { // R5
         m1 = (vin[3] <= 0.0) ? R5_Minus : R5_Plus;  // Use the global R5_Minus/R5_Plus
         m3d_step = (vin[3] <= 0.0) ? R5_Minus_3D : R5_Plus_3D;
         again = true;
      }
      else if (fabs(vin[4]) > fabs(vin[0]) + delta) { // R6
         m1 = (vin[4] <= 0.0) ? R6_Minus : R6_Plus;  // Use the global R6_Minus/R6_Plus
         m3d_step = (vin[4] <= 0.0) ? R6_Minus_3D : R6_Plus_3D;
         again = true;
      }
      else if (fabs(vin[5]) > fabs(vin[0]) + delta) { // R7
         m1 = (vin[5] <= 0.0) ? R7_Minus : R7_Plus;  // Use the global R7_Minus/R7_Plus
         m3d_step = (vin[5] <= 0.0) ? R7_Minus_3D : R7_Plus_3D;
         again = true;
      }
      else if (vin[3] + vin[4] + vin[5] + fabs(vin[0]) + fabs(vin[1]) + delta < 0.0) { // R8
         m1 = R8;  // Use the global R8
         m3d_step = R8_3D;
         again = true;
      }
      else if ((fabs(vin[3] - vin[1]) <= delta && 2.0 * vin[4] - delta < vin[5]) ||
         (fabs(vin[3] + vin[1]) <= delta && vin[5] < 0.0)) { // R9
         m1 = (vin[3] <= 0.0) ? R9_Minus : R9_Plus;  // Use the global R9_Minus/R9_Plus
         m3d_step = (vin[3] <= 0.0) ? R9_Minus_3D : R9_Plus_3D;
         again = true;
      }
      else if ((fabs(vin[4] - vin[0]) <= delta && 2.0 * vin[3] - delta < vin[5]) ||
         (fabs(vin[4] + vin[0]) <= delta && vin[5] < 0.0)) { // R10
         m1 = (vin[4] <= 0.0) ? R10_Minus : R10_Plus;  // Use the global R10_Minus/R10_Plus
         m3d_step = (vin[4] <= 0.0) ? R10_Minus_3D : R10_Plus_3D;
         again = true;
      }
      else if ((fabs(vin[5] - vin[0]) <= delta && 2.0 * vin[3] - delta < vin[4]) ||
         (fabs(vin[5] + vin[0]) <= delta && vin[4] < 0.0)) { // R11
         m1 = (vin[5] <= 0.0) ? R11_Minus : R11_Plus;  // Use the global R11_Minus/R11_Plus
         m3d_step = (vin[5] <= 0.0) ? R11_Minus_3D : R11_Plus_3D;
         again = true;
      }
      else if (fabs(vin[3] + vin[4] + vin[5] + fabs(vin[0]) + fabs(vin[1])) <= delta &&
         (2.0 * (fabs(vin[0]) + vin[4]) + vin[5] > delta)) { // R12
         m1 = R12;  // Use the global R12
         m3d_step = R12_3D;
         again = true;
      }
      else {
         again = false;
         vout = vin;
      }

      if (again) {
         // Apply the transformation to G6 and update the matrices
         vout = m1 * vin;

         // Update the total transformation matrices
         mG6 = m1 * mG6;
         m3d = m3d_step * m3d;

         // After applying a reduction step, we need to re-standardize (MKnorm)
         // This is following the logic in Niggli::Reduce
         {
            // MKnorm again
            bool againMK = true;
            int mkCycleCount = 0;
            MatG6 step_matG6;  // Changed variable name to avoid redeclaration
            Matrix_3x3 step_mat3D;  // Changed variable name to avoid redeclaration

            // MKnorm: assure that g1<=g2<=g3
            G6 vtemp = vout;

            while (againMK && (mkCycleCount <= 5)) {
               ++mkCycleCount;
               againMK = false;
               step_matG6 = spnull;  // Using the renamed variable
               step_mat3D = spnull_3D;     // Using the renamed variable

               if ((fabs(vtemp[0]) > fabs(vtemp[1]) + delta + 1.e-12 * (vtemp[0] + vtemp[1])) ||
                  (fabs(vtemp[0] - vtemp[1]) < 1.e-38 + 1.e-12 * fabs(vtemp[0] + vtemp[1]) &&
                     delta < 1.0E-12 && fabs(vtemp[3]) > fabs(vtemp[4]) + delta + 1.e-12 * (fabs(vtemp[3]) + fabs(vtemp[4])))) {
                  // SP1
                  step_matG6 = sp1;  // Use the global sp1
                  step_mat3D = sp1_3D;
                  againMK = true;
               }
               else if ((fabs(vtemp[1]) > fabs(vtemp[2]) + delta + 1.e-12 * (vtemp[1] + vtemp[2])) ||
                  (fabs(vtemp[1] - vtemp[2]) < 1.e-38 + 1.e-12 * fabs(vtemp[1] + vtemp[2]) &&
                     delta < 1.0E-12 && fabs(vtemp[4]) > fabs(vtemp[5]) + delta + 1.e-12 * (fabs(vtemp[4]) + fabs(vtemp[5])))) {
                  // SP2
                  step_matG6 = sp2;  // Use the global sp2
                  step_mat3D = sp2_3D;
                  againMK = true;
               }

               if (againMK) {
                  G6 vtemp2 = step_matG6 * vtemp;
                  vtemp = vtemp2;

                  // Update the transformation matrices
                  mG6 = step_matG6 * mG6;
                  m3d = step_mat3D * m3d;
               }
            }

            // MKnorm: Ensure vector is +++ or ---
            int local_bMinusPattern = 0;  // Using a local variable with a different name
            int local_bZeroPattern = 0;   // Using a local variable with a different name
            if (vtemp[3] < delta + 1.0E-13 * (vtemp[1] + vtemp[2])) local_bMinusPattern |= 4;
            if (vtemp[4] < delta + 1.0E-13 * (vtemp[0] + vtemp[2])) local_bMinusPattern |= 2;
            if (vtemp[5] < delta + 1.0E-13 * (vtemp[0] + vtemp[1])) local_bMinusPattern |= 1;
            if (fabs(vtemp[3]) < delta + 1.0E-13 * (vtemp[1] + vtemp[2])) local_bZeroPattern |= 4;
            if (fabs(vtemp[4]) < delta + 1.0E-13 * (vtemp[0] + vtemp[2])) local_bZeroPattern |= 2;
            if (fabs(vtemp[5]) < delta + 1.0E-13 * (vtemp[0] + vtemp[1])) local_bZeroPattern |= 1;

            step_matG6 = spnull;
            step_mat3D = spnull_3D;

            switch (local_bMinusPattern) {
            case 0:  /*  +++  */
               step_matG6 = spnull;  // Use the global spnull
               step_mat3D = spnull_3D;
               break;
            case 1:  /* ++- -> --- */
               step_matG6 = sp34a;  // Use the global sp34a
               step_mat3D = sp34a_3D;
               break;
            case 2:  /* +-+ -> --- */
               step_matG6 = sp34b;  // Use the global sp34b
               step_mat3D = sp34b_3D;
               break;
            case 3:  /* +-- -> +++, but +0- -> -0- and +-0 -> --0 and +00 -> -00 */
               if ((local_bZeroPattern & 2) == 2) {
                  step_matG6 = sp34a;  // Use the global sp34a
                  step_mat3D = sp34a_3D;
                  break;
               }
               if ((local_bZeroPattern & 1) == 1) {
                  step_matG6 = sp34b;  // Use the global sp34b
                  step_mat3D = sp34b_3D;
                  break;
               }
               step_matG6 = sp34c;  // Use the global sp34c
               step_mat3D = sp34c_3D;
               break;
            case 4:  /* -++ -> --- */
               step_matG6 = sp34c;  // Use the global sp34c
               step_mat3D = sp34c_3D;
               break;
            case 5:  /* -+- -> +++, but 0+- -> 0-- and -+0 -> --0 and 0+0 -> 0-0 */
               if ((local_bZeroPattern & 4) == 4) {
                  step_matG6 = sp34a;  // Use the global sp34a
                  step_mat3D = sp34a_3D;
                  break;
               }
               if ((local_bZeroPattern & 1) == 1) {
                  step_matG6 = sp34c;  // Use the global sp34c
                  step_mat3D = sp34c_3D;
                  break;
               }
               step_matG6 = sp34b;  // Use the global sp34b
               step_mat3D = sp34b_3D;
               break;
            case 6:  /* --+ -> +++, but 0-+ -> 0-- and -0+ -> -0- and 00+ -> 00- */
               if ((local_bZeroPattern & 4) == 4) {
                  step_matG6 = sp34b;  // Use the global sp34b
                  step_mat3D = sp34b_3D;
                  break;
               }
               if ((local_bZeroPattern & 2) == 2) {
                  step_matG6 = sp34c;  // Use the global sp34c
                  step_mat3D = sp34c_3D;
                  break;
               }
               step_matG6 = sp34a;  // Use the global sp34a
               step_mat3D = sp34a_3D;
               break;
            case 7:
               step_matG6 = spnull;  // Use the global spnull
               step_mat3D = spnull_3D;
               break;
            }

            vtemp = step_matG6 * vtemp;

            // Update the transformation matrices
            mG6 = step_matG6 * mG6;
            m3d = step_mat3D * m3d;

            // Set the vector for the next iteration
            vin = vtemp;
         }

         // Clean up small values to avoid numerical issues
         for (size_t i = 3; i < 6; ++i)
            if (std::fabs(vin[i]) < 1.0E-10) vin[i] = 0.0;

         // Check for illegal values
         if (vin[0] < 0.0 || vin[1] < 0.0 || vin[2] < 0.0) {
            // Error case - negative squared values shouldn't happen
            return false;
         }
      }
      const double det = m3d.Det();
      if (std::abs(det - 1.0) > 0.001) {
         std::cout << "3D transformation determinant not 1.0\n";
      }

      ++count;
   }

   vout = vin;

   // Check if the reduction was successful
   bool isNearReduced = NearRed(vout, delta);
   m_ReductionCycleCount = count;

   // Verify that the matrices are correct
   G6 vcheck = mG6 * vi;
   double diffG6 = 0.0;
   for (int i = 0; i < 6; ++i) {
      diffG6 = std::max(diffG6, std::abs(vcheck[i] - vout[i]));
   }

   // If the G6 transformation is accurate but there are numerical issues with the 3D matrix,
   // we can try a sanity check to adjust the 3D matrix by verifying its determinant
   const double det = m3d.Det();
   if (std::abs(det - 1.0) > 0.001) {
      std::cout << "3D transformation determinant not 1.0\n";
   }
   if (m3d.Det() < 0.0) {
      std::cout << "ERROR IN NIGGLI REDUCTION COMPUTING 3D TRANSFORMATION\n";
   }
   return (count < maxCycle) || isNearReduced;
}
