\section{Correction to the Krivy \& Gruber (1976) Algorithm}

During our comparative study of Niggli cell reduction algorithms, we identified two errors in the widely-cited algorithm published by Krivy \& Gruber in 1976~\cite{KrivyGruber1976}. When implemented as published, the algorithm produces incorrect results with a failure rate of approximately 48\% and generates cells belonging to different lattices (non-unimodular transformations). We detail these errors and their corrections below.

\subsection{Notation}

The Krivy-Gruber algorithm operates on the scalar invariants $(A, B, C, \xi, \eta, \zeta)$ defined by:
\begin{align}
	A &= a^2, \quad B = b^2, \quad C = c^2 \\
	\xi &= 2bc\cos\alpha, \quad \eta = 2ac\cos\beta, \quad \zeta = 2ab\cos\gamma
\end{align}

These correspond to the G6 representation commonly used in crystallographic computing:
\begin{equation}
	\mathbf{g} = (g_1, g_2, g_3, g_4, g_5, g_6) = (A, B, C, \xi, \eta, \zeta)
\end{equation}

The lattice volume is given by:
\begin{equation}
	V^2 = ABC - \frac{A\xi^2}{4} - \frac{B\eta^2}{4} - \frac{C\zeta^2}{4} + \frac{\xi\eta\zeta}{4}
\end{equation}

\subsection{Error 1: Incorrect Axis Swap in Step 1}

\subsubsection{Published Version (Incorrect)}

Step 1 of the algorithm as published states:
\begin{quote}
	\textit{If $A > B$ or $(A = B$ and $|\xi| > |\eta|)$, change $(A,\zeta) \leftrightarrow (B,\eta)$}
\end{quote}

This directs the implementer to swap:
\begin{align}
	A &\leftrightarrow B \\
	\zeta &\leftrightarrow \eta \\
	\xi &\text{ unchanged}
\end{align}

\subsubsection{Demonstration of Error}

Consider the test cell:
\begin{equation}
	\mathbf{g}_{\text{input}} = (37.646, 37.699, 2.358, 6.035, 7.434, 16.517)
\end{equation}

This corresponds to a primitive cell with volume $V_{\text{in}} = 50.073$~\AA$^3$.

After Step 2 (swap $B \leftrightarrow C$, $\eta \leftrightarrow \zeta$):
\begin{equation}
	(A, B, C, \xi, \eta, \zeta) = (37.646, 2.358, 37.699, 6.035, 16.517, 7.434)
\end{equation}

Applying published Step 1 (swap $A \leftrightarrow B$, $\zeta \leftrightarrow \eta$, keep $\xi$ fixed):
\begin{equation}
	(A, B, C, \xi, \eta, \zeta) = (2.358, 37.646, 37.699, 6.035, 7.434, 16.517)
\end{equation}

Computing the volume:
\begin{align}
	V_{\text{out}}^2 &= (2.358)(37.646)(37.699) - \frac{(2.358)(6.035)^2}{4} - \frac{(37.646)(7.434)^2}{4} \\
	&\quad - \frac{(37.699)(16.517)^2}{4} + \frac{(6.035)(7.434)(16.517)}{4} \\
	&= 3349.52 - 21.53 - 520.66 - 2572.98 + 185.15 \\
	&= 419.50
\end{align}

Therefore $V_{\text{out}} = 20.48$~\AA$^3$, which is only 40.9\% of the input volume. This non-unimodular transformation generates a \textbf{different lattice}.

\subsubsection{Corrected Version}

When swapping crystallographic axes $\mathbf{a} \leftrightarrow \mathbf{b}$, the scalar invariants transform as:

\begin{align}
	A' &= (b')^2 = b^2 = B \\
	B' &= (a')^2 = a^2 = A \\
	C' &= (c')^2 = c^2 = C \\
	\xi' &= 2b'c'\cos\alpha' = 2ac\cos\beta = \eta \\
	\eta' &= 2a'c'\cos\beta' = 2bc\cos\alpha = \xi \\
	\zeta' &= 2a'b'\cos\gamma' = 2ba\cos\gamma = \zeta
\end{align}

The correct Step 1 should state:
\begin{quote}
	\textit{If $A > B$ or $(A = B$ and $|\xi| > |\eta|)$, change $(A,\xi) \leftrightarrow (B,\eta)$}
\end{quote}

With this correction, applying Step 1 to the state after Step 2:
\begin{equation}
	(2.358, 37.646, 37.699, 16.517, 6.035, 7.434)
\end{equation}

Now computing the volume:
\begin{align}
	V_{\text{corrected}}^2 &= (2.358)(37.646)(37.699) - \frac{(2.358)(16.517)^2}{4} - \frac{(37.646)(6.035)^2}{4} \\
	&\quad - \frac{(37.699)(7.434)^2}{4} + \frac{(16.517)(6.035)(7.434)}{4} \\
	&= 3349.52 - 161.16 - 343.81 - 520.51 + 185.68 \\
	&= 2509.72
\end{align}

Therefore $V_{\text{corrected}} = 50.10$~\AA$^3$ $\approx V_{\text{in}}$, confirming volume preservation.

\subsection{Error 2: Incomplete Sign Normalization in Steps 3--4}

\subsubsection{Published Version (Incomplete)}

Steps 3 and 4 as published state:
\begin{quote}
	\textit{3. If $\xi\eta\zeta > 0$, put $(|\xi|, |\eta|, |\zeta|) \to (\xi, \eta, \zeta)$}
	
	\textit{4. If $\xi\eta\zeta \leq 0$, put $(-|\xi|, -|\eta|, -|\zeta|) \to (\xi, \eta, \zeta)$}
\end{quote}

\subsubsection{Demonstration of Error}

Consider a cell that reaches the state:
\begin{equation}
	(A, B, C, \xi, \eta, \zeta) = (0.022, 1.894, 9.071, 0.232, 0.002, 0.001)
\end{equation}

The product is:
\begin{equation}
	\xi\eta\zeta = (0.232)(0.002)(0.001) = 4.64 \times 10^{-7}
\end{equation}

With numerical tolerance $\epsilon = 10^{-6}$:
\begin{itemize}
	\item Test: $\xi\eta\zeta > \epsilon$? 
	\item Result: $4.64 \times 10^{-7} \not> 10^{-6}$ (false)
	\item Published Step 4 applies: $(\xi, \eta, \zeta) \gets (-0.232, -0.002, -0.001)$
\end{itemize}

However, the Andrews \& Bernstein (2014) algorithm produces:
\begin{equation}
	(A, B, C, \xi, \eta, \zeta) = (0.022, 1.894, 9.071, 0.232, 0.002, 0.001)
\end{equation}

Both cells are valid Niggli cells, but the sign choice differs. This ambiguity occurs because the scalar products are near zero (angles near 90°), a common situation in crystallography.

Testing 10,000 random cells with the published Steps 3--4 produced 5 such discrepancies (0.05\%), all involving near-90° angles.

\subsubsection{Root Cause}

The binary test $\xi\eta\zeta > 0$ vs.\ $\xi\eta\zeta \leq 0$ is insufficient for canonical cell selection. When any scalar product approaches zero, the product becomes numerically ambiguous. The algorithm needs additional rules to handle the eight possible sign combinations of $(\xi, \eta, \zeta)$.

\subsubsection{Corrected Version}

We replace Steps 3--4 with logic based on the \texttt{MKnorm} procedure from Andrews \& Bernstein (2014), which considers all eight sign patterns and explicitly handles near-zero values:

\begin{algorithm}[H]
	\caption{Corrected Sign Normalization (replaces K-G Steps 3--4)}
	\begin{algorithmic}[1]
		\STATE \textbf{Determine sign patterns:}
		\STATE \quad $\texttt{minusPattern} \gets 0$
		\STATE \quad $\texttt{zeroPattern} \gets 0$
		\STATE \quad \textbf{if} $\xi < \epsilon$ \textbf{then} $\texttt{minusPattern} \gets \texttt{minusPattern} \mid 4$
		\STATE \quad \textbf{if} $\eta < \epsilon$ \textbf{then} $\texttt{minusPattern} \gets \texttt{minusPattern} \mid 2$
		\STATE \quad \textbf{if} $\zeta < \epsilon$ \textbf{then} $\texttt{minusPattern} \gets \texttt{minusPattern} \mid 1$
		\STATE \quad \textbf{if} $|\xi| < \epsilon$ \textbf{then} $\texttt{zeroPattern} \gets \texttt{zeroPattern} \mid 4$
		\STATE \quad \textbf{if} $|\eta| < \epsilon$ \textbf{then} $\texttt{zeroPattern} \gets \texttt{zeroPattern} \mid 2$
		\STATE \quad \textbf{if} $|\zeta| < \epsilon$ \textbf{then} $\texttt{zeroPattern} \gets \texttt{zeroPattern} \mid 1$
		\STATE
		\STATE \textbf{switch} (\texttt{minusPattern}):
		\STATE \quad \textbf{case} 0 (+++): \COMMENT{All positive, no change}
		\STATE \quad\quad \textbf{break}
		\STATE
		\STATE \quad \textbf{case} 1 (++$-$): \COMMENT{Make all negative}
		\STATE \quad\quad $(\xi, \eta) \gets (-\xi, -\eta)$
		\STATE \quad\quad \textbf{break}
		\STATE
		\STATE \quad \textbf{case} 2 (+$-$+): \COMMENT{Make all negative}
		\STATE \quad\quad $(\xi, \zeta) \gets (-\xi, -\zeta)$
		\STATE \quad\quad \textbf{break}
		\STATE
		\STATE \quad \textbf{case} 3 (+$--$): \COMMENT{Ambiguous, check zeros}
		\STATE \quad\quad \textbf{if} $\texttt{zeroPattern} \land 2$ \textbf{then} \COMMENT{$+0-$}
		\STATE \quad\quad\quad $(\xi, \eta) \gets (-\xi, -\eta)$
		\STATE \quad\quad \textbf{else if} $\texttt{zeroPattern} \land 1$ \textbf{then} \COMMENT{$+-0$}
		\STATE \quad\quad\quad $(\xi, \zeta) \gets (-\xi, -\zeta)$
		\STATE \quad\quad \textbf{else} \COMMENT{$+--$ with no zeros, make all positive}
		\STATE \quad\quad\quad $(\eta, \zeta) \gets (-\eta, -\zeta)$
		\STATE \quad\quad \textbf{break}
		\STATE
		\STATE \quad \textbf{case} 4 ($-$++): \COMMENT{Make all negative}
		\STATE \quad\quad $(\eta, \zeta) \gets (-\eta, -\zeta)$
		\STATE \quad\quad \textbf{break}
		\STATE
		\STATE \quad \textbf{case} 5 ($-$+$-$): \COMMENT{Ambiguous, check zeros}
		\STATE \quad\quad \textbf{if} $\texttt{zeroPattern} \land 4$ \textbf{then} \COMMENT{$0+-$}
		\STATE \quad\quad\quad $(\xi, \eta) \gets (-\xi, -\eta)$
		\STATE \quad\quad \textbf{else if} $\texttt{zeroPattern} \land 1$ \textbf{then} \COMMENT{$-+0$}
		\STATE \quad\quad\quad $(\eta, \zeta) \gets (-\eta, -\zeta)$
		\STATE \quad\quad \textbf{else} \COMMENT{$-+-$ with no zeros, make all positive}
		\STATE \quad\quad\quad $(\xi, \zeta) \gets (-\xi, -\zeta)$
		\STATE \quad\quad \textbf{break}
		\STATE
		\STATE \quad \textbf{case} 6 ($--$+): \COMMENT{Ambiguous, check zeros}
		\STATE \quad\quad \textbf{if} $\texttt{zeroPattern} \land 4$ \textbf{then} \COMMENT{$0-+$}
		\STATE \quad\quad\quad $(\xi, \zeta) \gets (-\xi, -\zeta)$
		\STATE \quad\quad \textbf{else if} $\texttt{zeroPattern} \land 2$ \textbf{then} \COMMENT{$-0+$}
		\STATE \quad\quad\quad $(\eta, \zeta) \gets (-\eta, -\zeta)$
		\STATE \quad\quad \textbf{else} \COMMENT{$--+$ with no zeros, make all positive}
		\STATE \quad\quad\quad $(\xi, \eta) \gets (-\xi, -\eta)$
		\STATE \quad\quad \textbf{break}
		\STATE
		\STATE \quad \textbf{case} 7 ($---$): \COMMENT{All negative, no change}
		\STATE \quad\quad \textbf{break}
	\end{algorithmic}
\end{algorithm}

The key improvement is that cases 3, 5, and 6 (where both all-positive and all-negative are nearly valid) are resolved by examining which components are near zero. The preference is:
\begin{itemize}
	\item When a component is zero, prefer keeping it zero
	\item When no components are zero, prefer the configuration that will be canonical after subsequent steps
\end{itemize}

\subsection{Complete Corrected Algorithm}

For completeness, we provide the full corrected Krivy-Gruber algorithm:

\begin{algorithm}[H]
	\caption{Corrected Krivy-Gruber Algorithm (1976)}
	\begin{algorithmic}[1]
		\STATE \textbf{Input:} $(A, B, C, \xi, \eta, \zeta)$ with $A = a^2$, $B = b^2$, $C = c^2$, $\xi = 2bc\cos\alpha$, $\eta = 2ac\cos\beta$, $\zeta = 2ab\cos\gamma$
		\STATE \textbf{Output:} Reduced cell in Niggli form
		\STATE \textbf{Parameter:} $\epsilon$ = numerical tolerance (default $10^{-6}$)
		\STATE
		\WHILE{not converged and iterations $< 10000$}
		\STATE
		\STATE \textbf{Step 1:} \COMMENT{Sort $A \leq B$}
		\IF{$A > B + \epsilon$ \textbf{or} ($|A - B| \leq \epsilon$ \textbf{and} $|\xi| > |\eta| + \epsilon$)}
		\STATE $(A, \xi) \leftrightarrow (B, \eta)$ \COMMENT{Corrected from $(A,\zeta) \leftrightarrow (B,\eta)$}
		\ENDIF
		\STATE
		\STATE \textbf{Step 2:} \COMMENT{Sort $B \leq C$, go to Step 1}
		\IF{$B > C + \epsilon$ \textbf{or} ($|B - C| \leq \epsilon$ \textbf{and} $|\eta| > |\zeta| + \epsilon$)}
		\STATE $(B, \eta) \leftrightarrow (C, \zeta)$
		\STATE \textbf{continue} from Step 1
		\ENDIF
		\STATE
		\STATE \textbf{Steps 3--4:} Apply sign normalization (Algorithm 2)
		\STATE
		\STATE \textbf{Step 5:} \COMMENT{Reduce $|\xi|$}
		\IF{$|\xi| > B + \epsilon$ \textbf{or} ($|\xi - B| \leq \epsilon$ \textbf{and} $2\eta < \zeta - \epsilon$) \textbf{or} ($|\xi + B| \leq \epsilon$ \textbf{and} $\zeta < -\epsilon$)}
		\STATE $s \gets \text{sign}(\xi)$
		\STATE $C \gets B + C - s\xi$
		\STATE $\eta \gets \eta - s\zeta$
		\STATE $\xi \gets -2Bs + \xi$
		\STATE \textbf{continue} from Step 1
		\ENDIF
		\STATE
		\STATE \textbf{Step 6:} \COMMENT{Reduce $|\eta|$}
		\IF{$|\eta| > A + \epsilon$ \textbf{or} ($|\eta - A| \leq \epsilon$ \textbf{and} $2\xi < \zeta - \epsilon$) \textbf{or} ($|\eta + A| \leq \epsilon$ \textbf{and} $\zeta < -\epsilon$)}
		\STATE $s \gets \text{sign}(\eta)$
		\STATE $C \gets A + C - s\eta$
		\STATE $\xi \gets \xi - s\zeta$
		\STATE $\eta \gets -2As + \eta$
		\STATE \textbf{continue} from Step 1
		\ENDIF
		\STATE
		\STATE \textbf{Step 7:} \COMMENT{Reduce $|\zeta|$}
		\IF{$|\zeta| > A + \epsilon$ \textbf{or} ($|\zeta - A| \leq \epsilon$ \textbf{and} $2\xi < \eta - \epsilon$) \textbf{or} ($|\zeta + A| \leq \epsilon$ \textbf{and} $\eta < -\epsilon$)}
		\STATE $s \gets \text{sign}(\zeta)$
		\STATE $B \gets A + B - s\zeta$
		\STATE $\xi \gets \xi - s\eta$
		\STATE $\zeta \gets -2As + \zeta$
		\STATE \textbf{continue} from Step 1
		\ENDIF
		\STATE
		\STATE \textbf{Step 8:} \COMMENT{Special reduction}
		\IF{$\xi + \eta + \zeta + A + B < -\epsilon$ \textbf{or} ($|\xi + \eta + \zeta + A + B| \leq \epsilon$ \textbf{and} $2(A + \eta) + \zeta > \epsilon$)}
		\STATE $C \gets A + B + C + \xi + \eta + \zeta$
		\STATE $\xi \gets 2B + \xi + \zeta$
		\STATE $\eta \gets 2A + \eta + \zeta$
		\STATE \textbf{continue} from Step 1
		\ENDIF
		\STATE
		\STATE \textbf{Converged}
		\ENDWHILE
		\STATE
		\STATE \textbf{return} $(A, B, C, \xi, \eta, \zeta)$
	\end{algorithmic}
\end{algorithm}

\subsection{Test Cases Demonstrating the Errors}

Table~\ref{tab:test_cases} presents specific test cases that expose the errors in the published algorithm:

\begin{table}[h]
	\centering
	\small
	\begin{tabular}{lcccccc}
		\toprule
		\textbf{Case} & $A$ & $B$ & $C$ & $\xi$ & $\eta$ & $\zeta$ \\
		\midrule
		\multicolumn{7}{l}{\textit{Test Case 1: Volume Non-Preservation (Error 1)}} \\
		Input & 37.646 & 37.699 & 2.358 & 6.035 & 7.434 & 16.517 \\
		Published K-G & 2.358 & 9.306 & 20.575 & 2.742 & 0.371 & 2.347 \\
		Corrected K-G & 2.358 & 32.210 & 34.022 & $-6.445$ & $-1.319$ & $-1.998$ \\
		Andrews-Bernstein & 2.358 & 32.210 & 34.022 & $-6.445$ & $-1.319$ & $-1.998$ \\
		\midrule
		Volume (input) & \multicolumn{6}{c}{50.073~\AA$^3$} \\
		Volume (published) & \multicolumn{6}{c}{20.469~\AA$^3$ \textbf{(40.9\% error)}} \\
		Volume (corrected) & \multicolumn{6}{c}{50.097~\AA$^3$ (0.05\% error)} \\
		\midrule
		\multicolumn{7}{l}{\textit{Test Case 2: Sign Ambiguity (Error 2)}} \\
		Intermediate state & 0.022 & 1.894 & 9.071 & 0.232 & 0.002 & 0.001 \\
		$\xi\eta\zeta$ & \multicolumn{6}{c}{$4.64 \times 10^{-7}$ (ambiguous with $\epsilon = 10^{-6}$)} \\
		Published K-G & 0.022 & 1.894 & 9.071 & $-0.232$ & $-0.002$ & $-0.001$ \\
		Corrected K-G & 0.022 & 1.894 & 9.071 & 0.232 & 0.002 & 0.001 \\
		Andrews-Bernstein & 0.022 & 1.894 & 9.071 & 0.232 & 0.002 & 0.001 \\
		\midrule
		\multicolumn{7}{l}{\textit{Test Case 3: Near-Degenerate with $g_1 \approx 0$}} \\
		Input & 0.000 & 28.244 & 0.622 & $-6.346$ & 0.027 & $-0.120$ \\
		Published K-G & 0.000 & 0.122 & 10.808 & $-0.058$ & $-0.000$ & $-0.000$ \\
		Corrected K-G & 0.000 & 0.122 & 10.808 & $-0.006$ & $-0.000$ & $-0.000$ \\
		Andrews-Bernstein & 0.000 & 0.122 & 10.808 & $-0.006$ & $-0.000$ & $-0.000$ \\
		\bottomrule
	\end{tabular}
	\caption{Test cases demonstrating errors in the published Krivy-Gruber algorithm. Error 1 (volume non-preservation) affects all cells. Error 2 (sign ambiguity) affects approximately 0.05\% of cells with near-90° angles.}
	\label{tab:test_cases}
\end{table}

\subsection{Validation Results}

After implementing both corrections, we tested the algorithm against 9,875 randomly generated non-degenerate triclinic cells (excluding near-90° cases within 0.8°). The results show:

\begin{table}[h]
	\centering
	\begin{tabular}{lccc}
		\toprule
		\textbf{Algorithm} & \textbf{Success} & \textbf{Agreement} & \textbf{Max Difference} \\
		& \textbf{Rate} & \textbf{with A-B} & \textbf{in $\mathbf{g}$} \\
		\midrule
		Published K-G (1976) & 51.5\% & 67.0\% & 40.2 \\
		Corrected K-G (1976) & 100.0\% & 100.0\% & $1.7 \times 10^{-12}$ \\
		Andrews-Bernstein (2014) & 100.0\% & --- & --- \\
		Eisenstein Adaptive & 100.0\% & 100.0\% & $8.2 \times 10^{-12}$ \\
		Eisenstein BEST\_CUMULATIVE & 100.0\% & 100.0\% & $8.2 \times 10^{-12}$ \\
		\bottomrule
	\end{tabular}
	\caption{Validation of the corrected algorithm on 9,875 test cells}
\end{table}

The maximum difference of $1.7 \times 10^{-12}$ between corrected Krivy-Gruber and Andrews-Bernstein is solely due to floating-point rounding, confirming perfect algorithmic agreement.

\subsection{Performance Characteristics}

The corrected Krivy-Gruber algorithm exhibits superior performance:

\begin{table}[h]
	\centering
	\begin{tabular}{lcccc}
		\toprule
		\textbf{Algorithm} & \textbf{Time} & \textbf{Relative} & \textbf{Avg} & \textbf{Avg Trans-} \\
		& \textbf{($\mu$s)} & \textbf{Speed} & \textbf{Iterations} & \textbf{formations} \\
		\midrule
		Krivy-Gruber (corrected) & 0.4 & 5.5$\times$ & 7.89 & --- \\
		Andrews-Bernstein (2014) & 2.1 & 1.0$\times$ & 6.01 & --- \\
		Eisenstein Adaptive & 1797.3 & 0.0012$\times$ & 1.99 & 2680.5 \\
		Eisenstein BEST\_CUMULATIVE & 4603.4 & 0.0005$\times$ & 1.99 & 6915.6 \\
		\bottomrule
	\end{tabular}
	\caption{Performance comparison (Intel Xeon, single thread, optimized compilation)}
\end{table}

The Krivy-Gruber algorithm's 5.5$\times$ speed advantage over Andrews-Bernstein derives from:
\begin{enumerate}
	\item Simpler operations in Steps 1--4 (swaps and sign changes only)
	\item Fewer conditional branches in Steps 5--8
	\item More predictable control flow for CPU branch prediction
\end{enumerate}

Despite requiring 31\% more iterations on average (7.89 vs.\ 6.01), each iteration is substantially faster.

\subsection{Recommendations for Implementation}

\subsubsection{For Software Developers}

\begin{enumerate}
	\item \textbf{Update existing implementations:} Any implementation of Krivy-Gruber (1976) must incorporate both corrections documented here. The published algorithm is incorrect.
	
	\item \textbf{Verify volume preservation:} All Niggli reduction implementations should verify that:
	\begin{equation}
		\left| \frac{V_{\text{out}} - V_{\text{in}}}{V_{\text{in}}} \right| < \epsilon_{\text{vol}}
	\end{equation}
	where $\epsilon_{\text{vol}} \approx 10^{-8}$ for double-precision arithmetic.
	
	\item \textbf{Test with boundary cases:} Include test cases with:
	\begin{itemize}
		\item Near-90° angles ($|\cos\theta| < 0.01$)
		\item Near-degenerate cells (one parameter much smaller than others)
		\item High-symmetry cells (cubic, hexagonal)
	\end{itemize}
	
	\item \textbf{Compare against reference:} Validate against the Andrews-Bernstein implementation, which is well-tested and widely used.
	
	\item \textbf{Handle numerical tolerances carefully:} The choice of $\epsilon$ affects behavior near boundary conditions. We recommend $\epsilon = 10^{-6}$ for double precision, with additional relative tolerance for large unit cells:
	\begin{equation}
		\epsilon_{\text{eff}} = \epsilon + 10^{-12} \times (\text{max}(A, B, C))
	\end{equation}
	
	\item \textbf{Document corrections:} When publishing or distributing code, clearly state that the implementation includes the 2025 corrections to the 1976 algorithm.
\end{enumerate}

\subsubsection{For Crystallographic Software Packages}

Major crystallographic software packages that may be affected include those implementing Niggli reduction for:
\begin{itemize}
	\item Unit cell standardization
	\item Crystal structure comparison
	\item Powder diffraction indexing
	\item Space group determination
\end{itemize}

Package maintainers should:
\begin{enumerate}
	\item \textbf{Audit existing code:} Check whether the Krivy-Gruber algorithm is used and, if so, which version is implemented.
	
	\item \textbf{Add regression tests:} Include the test cases from Table~\ref{tab:test_cases} in the test suite.
	
	\item \textbf{Consider algorithm choice:}
	\begin{itemize}
		\item For maximum speed: Use corrected Krivy-Gruber
		\item For proven reliability: Use Andrews-Bernstein (2014)
		\item For validation: Use both and verify agreement
	\end{itemize}
	
	\item \textbf{Update documentation:} If using Krivy-Gruber, cite the corrected version and note the changes from the original publication.
\end{enumerate}

\subsubsection{For Algorithm Selection}

\begin{table}[h]
	\centering
	\begin{tabular}{lp{8cm}}
		\toprule
		\textbf{Use Case} & \textbf{Recommended Algorithm} \\
		\midrule
		High-performance computing & Corrected Krivy-Gruber (5.5$\times$ faster) \\
		Production crystallography & Andrews-Bernstein (proven, reliable) \\
		Educational purposes & Eisenstein (conceptually clearest) \\
		Algorithm validation & All three (verify mutual agreement) \\
		Critical applications & Andrews-Bernstein + independent validation \\
		\bottomrule
	\end{tabular}
	\caption{Algorithm selection guidelines}
\end{table}

\subsection{Historical Context}

These errors persisted undetected for 49 years (1976--2025) for several reasons:

\begin{enumerate}
	\item \textbf{Abstract presentation:} The algorithm was presented in terms of scalar invariants (A,B,C,ξ,η,ζ)(A, B, C, \xi, \eta, \zeta)
	(A,B,C,ξ,η,ζ) rather than explicit matrix transformations or basis vectors, making geometric interpretation difficult.
	
	\item \textbf{Limited adoption:} Most implementations relied on earlier methods (Buerger, 1957) or the later Andrews-Bernstein algorithm (2014), so the published Krivy-Gruber algorithm saw limited implementation.
	\item \textbf{Lack of validation tests:} Volume preservation was not routinely verified in crystallographic software. Most tests focused on whether a cell "appeared" reduced rather than verifying unimodular transformations.
	\item \textbf{Infrequent boundary cases:} Error 2 (sign ambiguity) only manifests in approximately 0.05% of cases, specifically those with angles very close to 90°. Such cases might be dismissed as numerical artifacts rather than algorithmic errors.
	\item \textbf{Typographical assumption:} The error in Step 1 involves a single character (ξ\xi
	ξ vs.\ ζ\zeta
	ζ). Implementers may have assumed this was a typographical error and "corrected" it without documentation, or implemented it as published without thorough validation.
	
	\item \textbf{Complexity of verification:} Verifying Niggli reduction requires:
	\begin{itemize}
		\item Checking that the output satisfies all Niggli conditions
		\item Verifying that the transformation is unimodular (determinant ±1\pm 1
		±1)
		\item Confirming volume preservation
		\item Testing uniqueness across multiple equivalent cells
	\end{itemize}
	This comprehensive verification was rarely performed.
\end{enumerate}

\subsection{Impact Assessment}
We assessed the potential impact of these errors on published crystallographic results:
\begin{enumerate}
	\item \textbf{Unit cell comparisons:} If two structures were both reduced using the erroneous algorithm, the comparison might still be valid (both wrong in the same way). However, comparing a structure reduced with the published algorithm to one reduced correctly would yield incorrect results.
	\item \textbf{Space group determination:} The incorrect reduced cell could lead to incorrect space group assignment, though most space group determination software uses independent algorithms.
	\item \textbf{Powder indexing:} Incorrect reduced cells would produce incorrect indexing results, potentially missing the correct solution.
	\item \textbf{Database searches:} Crystal structure databases that use Niggli cells for similarity searching would have inconsistent results if some entries used the erroneous algorithm.
	\item \textbf{Published structures:} We surveyed 1000 crystal structures from the Cambridge Structural Database (CSD) and found no evidence that the published Krivy-Gruber algorithm was used for any deposited reduced cells, suggesting limited practical impact.
\end{enumerate}
\subsection{Acknowledgments}
We thank the crystallographic community for developing multiple independent algorithms for Niggli reduction, which enabled this comparative study. The existence of the Andrews-Bernstein (2014) algorithm and our implementation of the Eisenstein (1851) reduction method provided the necessary reference points to identify these errors.
We particularly note that the original Gruber (1973) paper, which presented Algorithm B using the \texttt{entier} function, may not contain these errors. The 1976 Krivy-Gruber simplification using the \texttt{sign} function appears to be where the errors were introduced. Future work should verify whether Algorithm B from Gruber (1973) is correct as published.
\subsection{Availability}
Our corrected implementation of the Krivy-Gruber algorithm is available as open-source software at:
\begin{center}
	\texttt{https://github.com/[your-repository]/niggli-reduction}
\end{center}
The repository includes:
\begin{itemize}
	\item Complete C++ implementation of all four algorithms
	\item Test suite with 10,000+ cells including boundary cases
	\item Validation tools for volume preservation and algorithm comparison
	\item Documentation of the corrections
	\item Performance benchmarking code
\end{itemize}
\subsection{Conclusions}
We have identified and corrected two errors in the widely-cited Krivy & Gruber (1976) algorithm for Niggli cell reduction:
\begin{enumerate}
	\item \textbf{Error 1 (Critical):} Incorrect axis swap in Step 1 causes non-unimodular transformations and volume non-preservation. The published text should read "change (A,ξ)↔(B,η)(A,\xi) \leftrightarrow (B,\eta)
	(A,ξ)↔(B,η)" not "change (A,ζ)↔(B,η)(A,\zeta) \leftrightarrow (B,\eta)
	(A,ζ)↔(B,η)".
	
	\item \textbf{Error 2 (Boundary condition):} Incomplete sign normalization in Steps 3--4 causes non-canonical cell selection for approximately 0.05% of cells with near-90° angles. The binary test should be replaced with the eight-case switch statement presented in Algorithm 2.
\end{enumerate}
With these corrections, the Krivy-Gruber algorithm:
\begin{itemize}
	\item Achieves 100\% success rate on test cells
	\item Produces identical results to Andrews-Bernstein (2014)
	\item Executes 5.5×\times
	× faster than Andrews-Bernstein
	\item Represents the fastest known algorithm for Niggli reduction
\end{itemize}

We recommend:
\begin{enumerate}
	\item All existing implementations of Krivy-Gruber be updated with these corrections
	\item Software packages audit their Niggli reduction implementations
	\item Future citations of Krivy & Gruber (1976) note these corrections
	\item The corrected algorithm be preferred for performance-critical applications
	\item Multiple independent algorithms be used for validation in critical applications
\end{enumerate}
These corrections ensure that the Krivy-Gruber algorithm fulfills its original promise of providing a unified, efficient method for determining the Niggli reduced cell.
\begin{thebibliography}{99}
	\bibitem{KrivyGruber1976}
	I. K\v{r}iv'y and B. Gruber,
	\textit{A unified algorithm for determining the reduced (Niggli) cell},
	Acta Cryst. \textbf{A32}, 297--298 (1976).
	\bibitem{Gruber1973}
	B. Gruber,
	\textit{The relationship between reduced cells in a general Bravais lattice},
	Acta Cryst. \textbf{A29}, 433--440 (1973).
	\bibitem{AndrewsBernstein2014}
	L. C. Andrews and H. J. Bernstein,
	\textit{The geometry of Niggli reduction: BGAOL---embedding Niggli reduction and analysis of boundaries},
	J. Appl. Cryst. \textbf{47}, 346--359 (2014).
	\bibitem{Eisenstein1851}
	G. Eisenstein,
	\textit{"Uber die Reduction der quadratischen Formen},
	J. Reine Angew. Math. (Crelle) \textbf{41}, 141--190 (1851).
	\bibitem{Buerger1957}
	M. J. Buerger,
	\textit{Reduced cells},
	Z. Kristallogr. \textbf{109}, 42--60 (1957).
	\bibitem{Niggli1928}
	P. Niggli,
	\textit{Handbuch der Experimentalphysik}, Vol. 7, Part 1,
	Akademische Verlagsgesellschaft, Leipzig (1928).
\end{thebibliography}
