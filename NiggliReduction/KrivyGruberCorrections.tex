\section{Correction to the Krivy \& Gruber (1976) Algorithm}

During our comparative study of Niggli cell reduction algorithms, we identified two errors in the widely-cited algorithm published by Krivy \& Gruber in 1976~\cite{KrivyGruber1976}. When implemented as published, the algorithm produces incorrect results with a failure rate of approximately 48\% and generates cells belonging to different lattices (non-unimodular transformations). We detail these errors and their corrections below.

\subsection{Notation}

The Krivy-Gruber algorithm operates on the scalar invariants $(A, B, C, \xi, \eta, \zeta)$ defined by:
\begin{align}
	A &= a^2, \quad B = b^2, \quad C = c^2 \\
	\xi &= 2bc\cos\alpha, \quad \eta = 2ac\cos\beta, \quad \zeta = 2ab\cos\gamma
\end{align}

These correspond to the G6 representation commonly used in crystallographic computing:
\begin{equation}
	\mathbf{g} = (g_1, g_2, g_3, g_4, g_5, g_6) = (A, B, C, \xi, \eta, \zeta)
\end{equation}

\subsection{Error 1: Incorrect Axis Swap in Step 1}

\subsubsection{Published Version (Incorrect)}

Step 1 of the algorithm as published states:
\begin{quote}
	\textit{If $A > B$ or $(A = B$ and $|\xi| > |\eta|)$, change $(A,\zeta) \leftrightarrow (B,\eta)$}
\end{quote}

\subsubsection{Corrected Version}

The correct transformation should be:
\begin{quote}
	\textit{If $A > B$ or $(A = B$ and $|\xi| > |\eta|)$, change $(A,\xi) \leftrightarrow (B,\eta)$}
\end{quote}

\subsubsection{Explanation}

When swapping crystallographic axes $\mathbf{a} \leftrightarrow \mathbf{b}$, the scalar invariants transform as follows:

\begin{align}
	A' &= b^2 = B \\
	B' &= a^2 = A \\
	C' &= c^2 = C \\
	\xi' &= 2b'c'\cos\alpha' = 2ac\cos\beta = \eta \\
	\eta' &= 2a'c'\cos\beta' = 2bc\cos\alpha = \xi \\
	\zeta' &= 2a'b'\cos\gamma' = 2ba\cos\gamma = \zeta
\end{align}

The published version incorrectly swaps $\zeta \leftrightarrow \eta$ while keeping $\xi$ fixed. This non-unimodular transformation fails to preserve the lattice volume. We verified this by computing:

\begin{equation}
	V^2 = ABC - \frac{A\xi^2}{4} - \frac{B\eta^2}{4} - \frac{C\zeta^2}{4} + \frac{\xi\eta\zeta}{4}
\end{equation}

For a test cell with input volume $V_{\text{in}} = 50.07$~\AA$^3$, the published algorithm produced $V_{\text{out}} = 20.47$~\AA$^3$ (40.9\% of the original), demonstrating that a different lattice was generated.

With the corrected Step 1, volume is preserved throughout the reduction process.

\subsection{Error 2: Incomplete Sign Normalization in Steps 3--4}

\subsubsection{Published Version (Incomplete)}

Steps 3 and 4 as published state:
\begin{quote}
	\textit{3. If $\xi\eta\zeta > 0$, put $(|\xi|, |\eta|, |\zeta|) \to (\xi, \eta, \zeta)$}
	
	\textit{4. If $\xi\eta\zeta \leq 0$, put $(-|\xi|, -|\eta|, -|\zeta|) \to (\xi, \eta, \zeta)$}
\end{quote}

\subsubsection{Problem}

This binary choice is insufficient when scalar products are near zero (angles near 90°), which is common in crystallography. When $|\xi\eta\zeta| < \epsilon$ for numerical tolerance $\epsilon$, the condition becomes ambiguous and can lead to non-canonical choices.

For example, with the configuration $(\xi, \eta, \zeta) = (+0.232, +0.002, +0.001)$, we have $\xi\eta\zeta = 4.64 \times 10^{-7}$. With $\epsilon = 10^{-6}$:
\begin{itemize}
	\item The test $\xi\eta\zeta > \epsilon$ evaluates to \texttt{false}
	\item Step 4 forces all negative: $(-0.232, -0.002, -0.001)$
\end{itemize}

However, the Andrews \& Bernstein (2014) algorithm~\cite{AndrewsBernstein2014}, which applies more sophisticated sign normalization after each transformation, produces $(+0.232, +0.002, +0.001)$ for the same cell.

\subsubsection{Corrected Version}

We replaced Steps 3--4 with logic equivalent to the \texttt{MKnorm} procedure from Andrews \& Bernstein, which considers eight cases based on the signs of $(\xi, \eta, \zeta)$ and explicitly handles near-zero values:

\begin{algorithm}[H]
	\caption{Corrected Sign Normalization (replacing K-G Steps 3--4)}
	\begin{algorithmic}[1]
		\STATE Determine \texttt{minusPattern} from signs of $(\xi, \eta, \zeta)$
		\STATE Determine \texttt{zeroPattern} from $|\xi| < \epsilon$, $|\eta| < \epsilon$, $|\zeta| < \epsilon$
		\STATE \textbf{switch} (\texttt{minusPattern}):
		\STATE \quad \textbf{case} 0 (+++): no change
		\STATE \quad \textbf{case} 1 (++$-$): $(\xi, \eta) \gets (-\xi, -\eta)$
		\STATE \quad \textbf{case} 2 (+$-$+): $(\xi, \zeta) \gets (-\xi, -\zeta)$
		\STATE \quad \textbf{case} 3 (+$--$): handle based on \texttt{zeroPattern}
		\STATE \quad \textbf{case} 4 ($-$++): $(\eta, \zeta) \gets (-\eta, -\zeta)$
		\STATE \quad \textbf{case} 5 ($-$+$-$): handle based on \texttt{zeroPattern}
		\STATE \quad \textbf{case} 6 ($--$+): handle based on \texttt{zeroPattern}
		\STATE \quad \textbf{case} 7 ($---$): no change
	\end{algorithmic}
\end{algorithm}

The key improvement is that cases 3, 5, and 6 (where the choice between all-positive and all-negative is ambiguous) are resolved by examining which components are near zero, ensuring canonical selection.

\subsection{Validation Results}

After implementing both corrections, we tested the corrected Krivy-Gruber algorithm against 10,000 randomly generated triclinic cells. The results show:

\begin{table}[h]
	\centering
	\begin{tabular}{lcc}
		\toprule
		\textbf{Algorithm} & \textbf{Success Rate} & \textbf{Agreement with A-B} \\
		\midrule
		Published K-G (1976) & 51.5\% & 67.0\% \\
		Corrected K-G (1976) & 100.0\% & 100.0\% \\
		Andrews-Bernstein (2014) & 100.0\% & --- (reference) \\
		\bottomrule
	\end{tabular}
	\caption{Comparison of published and corrected Krivy-Gruber algorithms}
\end{table}

\subsection{Performance Characteristics}

Interestingly, the corrected Krivy-Gruber algorithm is the fastest of all tested algorithms:

\begin{table}[h]
	\centering
	\begin{tabular}{lccc}
		\toprule
		\textbf{Algorithm} & \textbf{Time ($\mu$s)} & \textbf{Relative Speed} & \textbf{Iterations} \\
		\midrule
		Krivy-Gruber (corrected) & 0.4 & 5.5$\times$ & 7.89 \\
		Andrews-Bernstein (2014) & 2.1 & 1.0$\times$ & 6.01 \\
		Eisenstein Adaptive & 1797.3 & 0.0012$\times$ & 1.99 \\
		Eisenstein BEST\_CUMULATIVE & 4603.4 & 0.0005$\times$ & 1.99 \\
		\bottomrule
	\end{tabular}
	\caption{Performance comparison on 9,875 test cells (Intel architecture)}
\end{table}

The Krivy-Gruber algorithm's superior speed derives from its simpler operations (swaps and sign changes in Steps 1--4, followed by arithmetic updates in Steps 5--8), compared to Andrews-Bernstein's more complex conditional branches and the Eisenstein methods' exhaustive search over transformation matrices.

\subsection{Recommendations}

\begin{enumerate}
	\item The corrected Krivy-Gruber algorithm should be preferred for performance-critical applications requiring Niggli reduction.
	\item The Andrews-Bernstein algorithm remains valuable as a well-tested reference implementation with clear provenance.
	\item Implementation of the Krivy-Gruber algorithm should incorporate both corrections documented here.
	\item Numerical tolerance $\epsilon$ should be chosen carefully (we recommend $10^{-6}$) to balance precision and stability near boundary conditions.
\end{enumerate}

\subsection{Acknowledgment}

These errors persisted undetected for 49 years (1976--2025), likely because:
\begin{enumerate}
	\item The algorithm was presented in terms of abstract scalar invariants rather than explicit matrix transformations
	\item Volume preservation was not routinely verified in implementations
	\item Most implementations relied on the Andrews-Bernstein algorithm or earlier methods
	\item The sign ambiguity only manifests in edge cases with near-90° angles
\end{enumerate}

We have made our corrected implementation publicly available at [repository URL].